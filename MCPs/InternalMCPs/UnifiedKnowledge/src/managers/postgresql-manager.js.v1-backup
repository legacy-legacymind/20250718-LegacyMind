import pg from 'pg';
const { Pool } = pg;

export class PostgreSQLManager {
  constructor() {
    this.pool = null;
    this.isConnected = false;
  }

  async connect() {
    try {
      const connectionString = process.env.DATABASE_URL || 
        'postgresql://postgres:postgres@localhost:5432/legacymind';
      
      this.pool = new Pool({
        connectionString,
        max: 10,
        idleTimeoutMillis: 30000,
        connectionTimeoutMillis: 5000,
      });

      // Test connection
      const client = await this.pool.connect();
      await client.query('SELECT 1');
      client.release();
      
      console.error('[PostgreSQL] Connected to database');
      this.isConnected = true;
      
      // Ensure tables exist
      await this.createTablesIfNotExist();
      
      return true;
    } catch (error) {
      console.error('[PostgreSQL] Connection failed:', error);
      throw error;
    }
  }

  async disconnect() {
    if (this.pool) {
      await this.pool.end();
      this.isConnected = false;
    }
  }

  async createTablesIfNotExist() {
    const createTicketsTable = `
      CREATE TABLE IF NOT EXISTS uk_tickets (
        ticket_id VARCHAR(50) PRIMARY KEY,
        title TEXT NOT NULL,
        description TEXT,
        priority VARCHAR(20),
        type VARCHAR(20),
        category VARCHAR(30),
        system VARCHAR(50),
        reporter VARCHAR(50),
        assignee VARCHAR(50),
        tags JSONB DEFAULT '[]'::jsonb,
        acceptance_criteria JSONB DEFAULT '[]'::jsonb,
        estimated_hours DECIMAL(5,2) DEFAULT 0,
        status VARCHAR(20),
        resolution TEXT,
        members JSONB DEFAULT '[]'::jsonb,
        linked_tickets JSONB DEFAULT '[]'::jsonb,
        created_at TIMESTAMP,
        updated_at TIMESTAMP,
        archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`;

    const createDocsTable = `
      CREATE TABLE IF NOT EXISTS uk_system_docs (
        doc_id VARCHAR(50) PRIMARY KEY,
        title TEXT NOT NULL,
        content TEXT,
        category VARCHAR(30),
        system VARCHAR(50),
        version INTEGER DEFAULT 1,
        valid_from TIMESTAMP,
        valid_to TIMESTAMP,
        "references" JSONB DEFAULT '[]'::jsonb,
        created_at TIMESTAMP,
        updated_at TIMESTAMP,
        archived_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )`;

    try {
      await this.pool.query(createTicketsTable);
      await this.pool.query(createDocsTable);
      console.error('[PostgreSQL] Tables created/verified');
    } catch (error) {
      console.error('[PostgreSQL] Failed to create tables:', error);
      throw error;
    }
  }

  async archiveTicket(ticketData) {
    const query = `
      INSERT INTO uk_tickets (
        ticket_id, title, description, priority, type, category, system,
        reporter, assignee, tags, acceptance_criteria, estimated_hours,
        status, resolution, members, linked_tickets, created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
      )
      ON CONFLICT (ticket_id) 
      DO UPDATE SET
        title = EXCLUDED.title,
        description = EXCLUDED.description,
        priority = EXCLUDED.priority,
        type = EXCLUDED.type,
        category = EXCLUDED.category,
        system = EXCLUDED.system,
        reporter = EXCLUDED.reporter,
        assignee = EXCLUDED.assignee,
        tags = EXCLUDED.tags,
        acceptance_criteria = EXCLUDED.acceptance_criteria,
        estimated_hours = EXCLUDED.estimated_hours,
        status = EXCLUDED.status,
        resolution = EXCLUDED.resolution,
        members = EXCLUDED.members,
        linked_tickets = EXCLUDED.linked_tickets,
        updated_at = EXCLUDED.updated_at,
        archived_at = CURRENT_TIMESTAMP
    `;

    const values = [
      ticketData.ticket_id,
      ticketData.title,
      ticketData.description,
      ticketData.priority,
      ticketData.type,
      ticketData.category,
      ticketData.system,
      ticketData.reporter,
      ticketData.assignee,
      JSON.stringify(ticketData.tags || []),
      JSON.stringify(ticketData.acceptance_criteria || []),
      ticketData.estimated_hours || 0,
      ticketData.status,
      ticketData.resolution,
      JSON.stringify(ticketData.members || []),
      JSON.stringify(ticketData.linked_tickets || []),
      ticketData.created_at,
      ticketData.updated_at
    ];

    try {
      await this.pool.query(query, values);
      console.error(`[PostgreSQL] Archived ticket ${ticketData.ticket_id}`);
      return true;
    } catch (error) {
      console.error('[PostgreSQL] Failed to archive ticket:', error);
      throw error;
    }
  }

  async getArchivedTicket(ticketId) {
    const query = 'SELECT * FROM uk_tickets WHERE ticket_id = $1';
    
    try {
      const result = await this.pool.query(query, [ticketId]);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      const row = result.rows[0];
      return {
        ...row,
        tags: row.tags || [],
        acceptance_criteria: row.acceptance_criteria || [],
        members: row.members || [],
        linked_tickets: row.linked_tickets || []
      };
    } catch (error) {
      console.error('[PostgreSQL] Failed to get archived ticket:', error);
      throw error;
    }
  }

  async searchArchivedTickets(criteria) {
    let query = 'SELECT * FROM uk_tickets WHERE 1=1';
    const values = [];
    let paramCount = 0;

    if (criteria.status) {
      paramCount++;
      query += ` AND status = $${paramCount}`;
      values.push(criteria.status);
    }

    if (criteria.reporter) {
      paramCount++;
      query += ` AND reporter = $${paramCount}`;
      values.push(criteria.reporter);
    }

    if (criteria.assignee) {
      paramCount++;
      query += ` AND assignee = $${paramCount}`;
      values.push(criteria.assignee);
    }

    if (criteria.category) {
      paramCount++;
      query += ` AND category = $${paramCount}`;
      values.push(criteria.category);
    }

    query += ' ORDER BY archived_at DESC LIMIT 100';

    try {
      const result = await this.pool.query(query, values);
      return result.rows.map(row => ({
        ...row,
        tags: row.tags || [],
        acceptance_criteria: row.acceptance_criteria || [],
        members: row.members || [],
        linked_tickets: row.linked_tickets || []
      }));
    } catch (error) {
      console.error('[PostgreSQL] Failed to search archived tickets:', error);
      throw error;
    }
  }

  // System documentation operations (Phase 2)
  async archiveSystemDoc(docData) {
    const query = `
      INSERT INTO uk_system_docs (
        doc_id, title, content, category, system, version,
        valid_from, valid_to, "references", created_at, updated_at
      ) VALUES (
        $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
      )
      ON CONFLICT (doc_id) 
      DO UPDATE SET
        title = EXCLUDED.title,
        content = EXCLUDED.content,
        category = EXCLUDED.category,
        system = EXCLUDED.system,
        version = EXCLUDED.version,
        valid_from = EXCLUDED.valid_from,
        valid_to = EXCLUDED.valid_to,
        "references" = EXCLUDED."references",
        updated_at = EXCLUDED.updated_at,
        archived_at = CURRENT_TIMESTAMP
    `;

    const values = [
      docData.doc_id,
      docData.title,
      docData.content,
      docData.category,
      docData.system,
      docData.version || 1,
      docData.valid_from,
      docData.valid_to,
      JSON.stringify(docData.references || []),
      docData.created_at,
      docData.updated_at
    ];

    try {
      await this.pool.query(query, values);
      console.error(`[PostgreSQL] Archived system doc ${docData.doc_id}`);
      return true;
    } catch (error) {
      console.error('[PostgreSQL] Failed to archive system doc:', error);
      throw error;
    }
  }

  // Health check
  async healthCheck() {
    try {
      await this.pool.query('SELECT 1');
      return { status: 'healthy', timestamp: new Date().toISOString() };
    } catch (error) {
      return { 
        status: 'unhealthy', 
        error: error.message, 
        timestamp: new Date().toISOString() 
      };
    }
  }
}