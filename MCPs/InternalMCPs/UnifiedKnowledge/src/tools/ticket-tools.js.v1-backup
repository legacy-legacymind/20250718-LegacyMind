import { v4 as uuidv4 } from 'uuid';

export const ticketTools = {
  getToolDefinitions() {
    return [
      {
        name: "uk_ticket",
        description: "Manage tickets in UnifiedKnowledge - create, update, search, and organize project tickets",
        inputSchema: {
          type: "object",
          properties: {
            action: {
              type: "string",
              enum: ["create", "update", "get", "search", "list", "close", "assign", "add_member", "link_tickets"],
              description: "Action to perform on tickets"
            },
            title: {
              type: "string",
              description: "Ticket title (for create/update)"
            },
            description: {
              type: "string",
              description: "Detailed description of the ticket (for create/update)"
            },
            priority: {
              type: "string",
              enum: ["LOW", "MEDIUM", "HIGH", "CRITICAL"],
              description: "Ticket priority level (for create/update)"
            },
            type: {
              type: "string",
              enum: ["BUG", "FEATURE", "TASK", "IMPROVEMENT", "RESEARCH"],
              description: "Type of ticket (for create/update)"
            },
            category: {
              type: "string",
              description: "Ticket category (e.g., SECURITY, UI, BACKEND) (for create/update)"
            },
            system: {
              type: "string",
              description: "System or component affected (for create/update)"
            },
            reporter: {
              type: "string",
              description: "Person reporting the ticket (for create)"
            },
            assignee: {
              type: "string",
              description: "Person assigned to the ticket (for create/update/assign)"
            },
            tags: {
              type: "array",
              items: { type: "string" },
              description: "Tags for categorization (for create/update)"
            },
            acceptance_criteria: {
              type: "array",
              items: { type: "string" },
              description: "List of acceptance criteria (for create/update)"
            },
            estimated_hours: {
              type: "number",
              description: "Estimated hours to complete (for create/update)"
            },
            ticket_id: {
              type: "string",
              description: "Ticket ID (for get/update/close/assign/link_tickets)"
            },
            query: {
              type: "string",
              description: "Search query (for search)"
            },
            filters: {
              type: "object",
              description: "Search filters (for search/list)"
            },
            status: {
              type: "string",
              enum: ["OPEN", "IN_PROGRESS", "BLOCKED", "REVIEW", "TESTING", "CLOSED", "CANCELLED"],
              description: "Ticket status (for update)"
            },
            resolution: {
              type: "string",
              description: "Resolution notes (for close)"
            },
            member_name: {
              type: "string",
              description: "Federation member name (for add_member)"
            },
            member_role: {
              type: "string",
              description: "Federation member role (for add_member)"
            },
            linked_ticket_id: {
              type: "string",
              description: "ID of ticket to link (for link_tickets)"
            },
            link_type: {
              type: "string",
              enum: ["BLOCKS", "BLOCKED_BY", "RELATES_TO", "DUPLICATE_OF", "CHILD_OF", "PARENT_OF"],
              description: "Type of link relationship (for link_tickets)"
            }
          },
          required: ["action"]
        }
      }
    ];
  },

  async handleTool(toolName, args, services) {
    if (toolName !== 'uk_ticket') {
      throw new Error(`Unknown tool: ${toolName}`);
    }
    
    const { action } = args;
    
    try {
      switch (action) {
        case 'create':
          return await this.createTicket(args, services);
        case 'update':
          return await this.updateTicket(args, services);
        case 'get':
          return await this.getTicket(args, services);
        case 'search':
          return await this.searchTickets(args, services);
        case 'list':
          return await this.listTickets(args, services);
        case 'close':
          return await this.closeTicket(args, services);
        case 'assign':
          return await this.assignTicket(args, services);
        case 'add_member':
          return await this.addMember(args, services);
        case 'link_tickets':
          return await this.linkTickets(args, services);
        default:
          throw new Error(`Unknown action: ${action}`);
      }
    } catch (error) {
      console.error(`[TicketTools] Error in ${action}:`, error);
      throw error;
    }
  },

  async createTicket(args, services) {
    const { redis, postgres, qdrant, embedding } = services;
    
    // Validate required fields
    if (!args.title) throw new Error('Title is required');
    if (!args.priority) throw new Error('Priority is required');
    if (!args.type) throw new Error('Type is required');
    if (!args.category) throw new Error('Category is required');
    if (!args.reporter) throw new Error('Reporter is required');
    
    // Validate enum values
    const validPriorities = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
    const validTypes = ['BUG', 'FEATURE', 'TASK', 'IMPROVEMENT', 'RESEARCH'];
    const validStatuses = ['OPEN', 'IN_PROGRESS', 'BLOCKED', 'REVIEW', 'TESTING', 'CLOSED', 'CANCELLED'];
    
    if (!validPriorities.includes(args.priority)) {
      throw new Error(`Invalid priority: ${args.priority}. Must be one of: ${validPriorities.join(', ')}`);
    }
    if (!validTypes.includes(args.type)) {
      throw new Error(`Invalid type: ${args.type}. Must be one of: ${validTypes.join(', ')}`);
    }
    
    // Generate ticket ID
    const date = new Date().toISOString().split('T')[0].replace(/-/g, '');
    const reporter = args.reporter.toUpperCase();
    const randomId = uuidv4().split('-')[0];
    const ticketId = `${date}-${reporter}-${randomId}`;
    
    // Create ticket object
    const ticket = {
      ticket_id: ticketId,
      title: args.title,
      description: args.description || null,
      priority: args.priority,
      type: args.type,
      category: args.category,
      system: args.system || null,
      reporter: args.reporter,
      assignee: args.assignee || 'unassigned',
      tags: args.tags || [],
      acceptance_criteria: args.acceptance_criteria || [],
      estimated_hours: args.estimated_hours || 0,
      status: 'OPEN',
      resolution: null,
      members: [],
      linked_tickets: [],
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    };
    
    // Store in Redis
    await redis.storeTicket(ticketId, ticket);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticketId,
            message: "Ticket created successfully",
            ticket: ticket
          }, null, 2)
        }
      ]
    };
  },

  async updateTicket(args, services) {
    const { redis, postgres, qdrant, embedding } = services;
    const { ticket_id } = args;
    
    // Validate required fields
    if (!ticket_id) throw new Error('ticket_id is required for update');
    
    // Get existing ticket
    const ticket = await redis.getTicket(ticket_id);
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    
    // Build updates object from individual fields in args
    const updates = {};
    const updateableFields = [
      'title', 'description', 'priority', 'type', 'category', 
      'system', 'assignee', 'tags', 'acceptance_criteria', 
      'estimated_hours', 'status'
    ];
    
    updateableFields.forEach(field => {
      if (args[field] !== undefined) {
        updates[field] = args[field];
      }
    });
    
    // Validate that at least one field is being updated
    if (Object.keys(updates).length === 0) {
      throw new Error('No fields provided for update');
    }
    
    // Validate enum values if they're being updated
    const validPriorities = ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'];
    const validTypes = ['BUG', 'FEATURE', 'TASK', 'IMPROVEMENT', 'RESEARCH'];
    const validStatuses = ['OPEN', 'IN_PROGRESS', 'BLOCKED', 'REVIEW', 'TESTING', 'CLOSED', 'CANCELLED'];
    
    if (updates.priority && !validPriorities.includes(updates.priority)) {
      throw new Error(`Invalid priority: ${updates.priority}. Must be one of: ${validPriorities.join(', ')}`);
    }
    if (updates.type && !validTypes.includes(updates.type)) {
      throw new Error(`Invalid type: ${updates.type}. Must be one of: ${validTypes.join(', ')}`);
    }
    if (updates.status && !validStatuses.includes(updates.status)) {
      throw new Error(`Invalid status: ${updates.status}. Must be one of: ${validStatuses.join(', ')}`);
    }
    
    // Apply updates
    const updatedTicket = {
      ...ticket,
      ...updates,
      updated_at: new Date().toISOString()
    };
    
    // Handle status changes to completed states
    const completedStates = ['CLOSED', 'CANCELLED'];
    const wasCompleted = completedStates.includes(ticket.status);
    const isCompleted = completedStates.includes(updatedTicket.status);
    
    // Store updated ticket in Redis
    await redis.storeTicket(ticket_id, updatedTicket);
    
    // If ticket was closed/cancelled, archive it
    if (!wasCompleted && isCompleted) {
      // Archive to PostgreSQL
      await postgres.archiveTicket(updatedTicket);
      
      // Generate embedding for semantic search
      const ticketEmbedding = await embedding.generateTicketEmbedding(updatedTicket);
      
      // Store in Qdrant
      // Use ticket_id directly as Qdrant supports UUID strings
      await qdrant.upsertTicketEmbedding(ticket_id, ticketEmbedding, updatedTicket);
    }
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            message: "Ticket updated successfully",
            ticket: updatedTicket,
            archived: !wasCompleted && isCompleted
          }, null, 2)
        }
      ]
    };
  },

  async queryTickets(args, services) {
    const { redis, postgres, qdrant, embedding } = services;
    const { ticket_id, include_closed, search_query, filters } = args;
    
    // Single ticket query
    if (ticket_id) {
      const ticket = await redis.getTicket(ticket_id);
      
      if (!ticket) {
        // Check archives
        const archived = await postgres.getArchivedTicket(ticket_id);
        if (archived) {
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  ticket: archived,
                  source: "archive"
                }, null, 2)
              }
            ]
          };
        }
        
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: false,
                message: `Ticket ${ticket_id} not found`
              }, null, 2)
            }
          ]
        };
      }
      
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              success: true,
              ticket: ticket,
              source: "active"
            }, null, 2)
          }
        ]
      };
    }
    
    // Semantic search
    if (search_query) {
      const queryEmbedding = await embedding.generateQueryEmbedding(search_query);
      const results = await qdrant.searchTickets(queryEmbedding, 20, filters);
      
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              success: true,
              query: search_query,
              count: results.length,
              tickets: results
            }, null, 2)
          }
        ]
      };
    }
    
    // Get all tickets
    let tickets = await redis.getAllActiveTickets();
    
    if (include_closed) {
      const closedTickets = await redis.getAllClosedTickets();
      tickets = [...tickets, ...closedTickets];
    }
    
    // Apply filters
    if (filters) {
      tickets = tickets.filter(ticket => {
        if (filters.status && ticket.status !== filters.status) return false;
        if (filters.assignee && ticket.assignee !== filters.assignee) return false;
        if (filters.reporter && ticket.reporter !== filters.reporter) return false;
        if (filters.category && ticket.category !== filters.category) return false;
        if (filters.priority && ticket.priority !== filters.priority) return false;
        return true;
      });
    }
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            count: tickets.length,
            tickets: tickets
          }, null, 2)
        }
      ]
    };
  },

  async deleteTicket(args, services) {
    const { redis, postgres, qdrant, embedding } = services;
    const { ticket_id, confirm } = args;
    
    if (!confirm) {
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              success: false,
              message: "Deletion not confirmed. Set confirm=true to delete."
            }, null, 2)
          }
        ]
      };
    }
    
    // Check if ticket exists
    const ticket = await redis.getTicket(ticket_id);
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    
    // Delete from Redis
    await redis.deleteTicket(ticket_id);
    
    // Delete from Qdrant if it was archived
    if (['CLOSED', 'CANCELLED'].includes(ticket.status)) {
      // Use ticket_id directly as Qdrant supports UUID strings
      await qdrant.deleteTicketEmbedding(ticket_id);
    }
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            message: "Ticket deleted successfully"
          }, null, 2)
        }
      ]
    };
  },

  async addMember(args, services) {
    const { redis } = services;
    const { ticket_id, member_name, member_role } = args;
    
    // Validate required fields
    if (!ticket_id) throw new Error('ticket_id is required');
    if (!member_name) throw new Error('member_name is required');
    if (!member_role) throw new Error('member_role is required');
    
    // Validate member role
    const validRoles = ['OBSERVER', 'CONTRIBUTOR', 'REVIEWER', 'LEAD'];
    if (!validRoles.includes(member_role)) {
      throw new Error(`Invalid member_role: ${member_role}. Must be one of: ${validRoles.join(', ')}`);
    }
    
    const ticket = await redis.getTicket(ticket_id);
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    
    // Check if member already exists
    const existingMember = ticket.members.find(m => m.member_name === member_name);
    if (existingMember) {
      existingMember.role = member_role;
    } else {
      ticket.members.push({
        member_name,
        role: member_role,
        added_at: new Date().toISOString()
      });
    }
    
    ticket.updated_at = new Date().toISOString();
    await redis.storeTicket(ticket_id, ticket);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            member_name: member_name,
            role: member_role,
            message: "Member added successfully"
          }, null, 2)
        }
      ]
    };
  },

  async removeMember(args, services) {
    const { redis } = services;
    const { ticket_id, member_name } = args;
    
    // Validate required fields
    if (!ticket_id) throw new Error('ticket_id is required');
    if (!member_name) throw new Error('member_name is required');
    
    const ticket = await redis.getTicket(ticket_id);
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    
    // Check if members array exists
    if (!ticket.members || ticket.members.length === 0) {
      throw new Error('No members found on this ticket');
    }
    
    ticket.members = ticket.members.filter(m => m.member_name !== member_name);
    ticket.updated_at = new Date().toISOString();
    
    await redis.storeTicket(ticket_id, ticket);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            member_name: member_name,
            message: "Member removed successfully"
          }, null, 2)
        }
      ]
    };
  },

  async getTicket(args, services) {
    return this.queryTickets({ ticket_id: args.ticket_id }, services);
  },

  async searchTickets(args, services) {
    return this.queryTickets({ search_query: args.query, filters: args.filters }, services);
  },

  async listTickets(args, services) {
    return this.queryTickets({ filters: args.filters }, services);
  },

  async closeTicket(args, services) {
    return this.updateTicket({
      ticket_id: args.ticket_id,
      status: 'CLOSED',
      resolution: args.resolution || 'Closed'
    }, services);
  },

  async assignTicket(args, services) {
    return this.updateTicket({
      ticket_id: args.ticket_id,
      assignee: args.assignee
    }, services);
  },

  async linkTickets(args, services) {
    return this.linkTicket({
      ticket_id: args.ticket_id,
      linked_ticket_id: args.linked_ticket_id,
      link_type: args.link_type
    }, services);
  },

  async linkTicket(args, services) {
    const { redis } = services;
    const { ticket_id, linked_ticket_id, link_type } = args;
    
    // Validate required fields
    if (!ticket_id) throw new Error('ticket_id is required');
    if (!linked_ticket_id) throw new Error('linked_ticket_id is required');
    if (!link_type) throw new Error('link_type is required');
    
    // Validate link type
    const validLinkTypes = ['BLOCKS', 'BLOCKED_BY', 'RELATES_TO', 'DUPLICATE_OF', 'CHILD_OF', 'PARENT_OF'];
    if (!validLinkTypes.includes(link_type)) {
      throw new Error(`Invalid link_type. Must be one of: ${validLinkTypes.join(', ')}`);
    }
    
    // Get both tickets
    const ticket = await redis.getTicket(ticket_id);
    const linkedTicket = await redis.getTicket(linked_ticket_id);
    
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    if (!linkedTicket) {
      throw new Error(`Linked ticket ${linked_ticket_id} not found`);
    }
    
    // Initialize linked_tickets array if it doesn't exist
    if (!ticket.linked_tickets) {
      ticket.linked_tickets = [];
    }
    if (!linkedTicket.linked_tickets) {
      linkedTicket.linked_tickets = [];
    }
    
    // Add link to primary ticket
    const existingLink = ticket.linked_tickets.find(l => l.ticket_id === linked_ticket_id);
    if (existingLink) {
      existingLink.link_type = link_type;
    } else {
      ticket.linked_tickets.push({
        ticket_id: linked_ticket_id,
        link_type: link_type,
        linked_at: new Date().toISOString()
      });
    }
    
    // Add reciprocal link
    const reciprocalType = this.getReciprocalLinkType(link_type);
    const reciprocalLink = linkedTicket.linked_tickets.find(l => l.ticket_id === ticket_id);
    if (reciprocalLink) {
      reciprocalLink.link_type = reciprocalType;
    } else {
      linkedTicket.linked_tickets.push({
        ticket_id: ticket_id,
        link_type: reciprocalType,
        linked_at: new Date().toISOString()
      });
    }
    
    // Update both tickets
    ticket.updated_at = new Date().toISOString();
    linkedTicket.updated_at = new Date().toISOString();
    
    await redis.storeTicket(ticket_id, ticket);
    await redis.storeTicket(linked_ticket_id, linkedTicket);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            linked_ticket_id: linked_ticket_id,
            link_type: link_type,
            message: "Tickets linked successfully"
          }, null, 2)
        }
      ]
    };
  },

  async unlinkTicket(args, services) {
    const { redis } = services;
    const { ticket_id, linked_ticket_id } = args;
    
    // Get both tickets
    const ticket = await redis.getTicket(ticket_id);
    const linkedTicket = await redis.getTicket(linked_ticket_id);
    
    if (!ticket) {
      throw new Error(`Ticket ${ticket_id} not found`);
    }
    if (!linkedTicket) {
      throw new Error(`Linked ticket ${linked_ticket_id} not found`);
    }
    
    // Remove links
    ticket.linked_tickets = ticket.linked_tickets.filter(l => l.ticket_id !== linked_ticket_id);
    linkedTicket.linked_tickets = linkedTicket.linked_tickets.filter(l => l.ticket_id !== ticket_id);
    
    // Update both tickets
    ticket.updated_at = new Date().toISOString();
    linkedTicket.updated_at = new Date().toISOString();
    
    await redis.storeTicket(ticket_id, ticket);
    await redis.storeTicket(linked_ticket_id, linkedTicket);
    
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            ticket_id: ticket_id,
            linked_ticket_id: linked_ticket_id,
            message: "Tickets unlinked successfully"
          }, null, 2)
        }
      ]
    };
  },

  async getHelp(args) {
    const { topic } = args;
    
    const helpTopics = {
      overview: `UnifiedKnowledge Ticket System Help

The ticket system provides comprehensive ticket management with multi-database support:
- Redis for active ticket storage
- PostgreSQL for archival
- Qdrant for semantic search

Available tools:
- uk_tickets.create - Create new tickets
- uk_tickets.update - Update existing tickets
- uk_tickets.query - Query tickets with filters or semantic search
- uk_tickets.delete - Delete tickets (requires confirmation)
- uk_tickets.add_member - Add federation members to tickets
- uk_tickets.remove_member - Remove members from tickets
- uk_tickets.link_ticket - Create relationships between tickets
- uk_tickets.unlink_ticket - Remove ticket relationships
- uk_tickets.help - This help system`,

      create: `Creating Tickets

Required fields:
- title: Clear, descriptive title
- priority: LOW, MEDIUM, HIGH, or CRITICAL
- type: BUG, FEATURE, TASK, IMPROVEMENT, or RESEARCH
- category: SECURITY, UI, BACKEND, etc.
- reporter: Person creating the ticket

Optional fields:
- description: Detailed explanation
- system: Affected system/component
- assignee: Person responsible (defaults to "unassigned")
- tags: Array of tags for categorization
- acceptance_criteria: Array of completion criteria
- estimated_hours: Time estimate

Ticket IDs are auto-generated: YYYYMMDD-REPORTER-randomId`,

      update: `Updating Tickets

You can update any field of an existing ticket.

Status values:
- OPEN: New ticket
- IN_PROGRESS: Being worked on
- BLOCKED: Waiting on dependency
- REVIEW: Under review
- TESTING: In testing phase
- CLOSED: Completed successfully
- CANCELLED: Will not be completed

When status changes to CLOSED or CANCELLED:
- Ticket is archived to PostgreSQL
- Embedding is generated for semantic search
- Stored in Qdrant for vector search
- Redis entry gets 1-hour TTL`,

      query: `Querying Tickets

Three query modes:

1. Single ticket: Provide ticket_id
2. All tickets: Omit ticket_id
3. Semantic search: Provide search_query

Options:
- include_closed: Include closed tickets
- filters: Filter by status, assignee, reporter, category, priority

Semantic search uses OpenAI embeddings to find related tickets.`,

      delete: `Deleting Tickets

Deletion requires explicit confirmation (confirm=true).

Process:
- Removes from Redis
- Removes from Qdrant if archived
- Does NOT remove from PostgreSQL archive

Use with caution - deletions are permanent.`,

      members: `Managing Members

Federation members can be added to tickets with specific roles:
- OBSERVER: Can view but not modify
- CONTRIBUTOR: Can work on the ticket
- REVIEWER: Reviews work done
- LEAD: Leads the ticket effort

Members are tracked with their role and timestamp.`,

      linking: `Linking Tickets

Link types:
- BLOCKS/BLOCKED_BY: Dependency relationships
- RELATES_TO: General relationship
- DUPLICATE_OF: Mark as duplicate
- PARENT_OF/CHILD_OF: Hierarchical relationship

Links are bidirectional - linking A to B also creates the reciprocal link.`,

      workflow: `Typical Workflow

1. Create ticket with initial details
2. Add members and assign
3. Link related tickets
4. Update status as work progresses
5. Add resolution when closing
6. Closed tickets are automatically archived

Best practices:
- Keep titles clear and searchable
- Use consistent categories
- Update status regularly
- Add resolution details when closing
- Use semantic search to find duplicates`
    };
    
    const helpText = helpTopics[topic] || helpTopics.overview;
    
    return {
      content: [
        {
          type: "text",
          text: helpText
        }
      ]
    };
  },

  getReciprocalLinkType(linkType) {
    const reciprocals = {
      'BLOCKS': 'BLOCKED_BY',
      'BLOCKED_BY': 'BLOCKS',
      'RELATES_TO': 'RELATES_TO',
      'DUPLICATE_OF': 'DUPLICATE_OF',
      'PARENT_OF': 'CHILD_OF',
      'CHILD_OF': 'PARENT_OF'
    };
    
    return reciprocals[linkType] || linkType;
  }
};