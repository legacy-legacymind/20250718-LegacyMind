import { promises as fs } from 'fs';
import path from 'path';
import { z } from 'zod';
import { redisManager } from '../shared/redis-manager.js';
import { zInstanceId, zContent } from '../shared/validators.js';
import { KEY_SCHEMA } from '../shared/key-schema.js';
import { rateLimiter } from '../shared/rate-limiter.js';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger.js';

const MAX_CONTEXT_SIZE = 50000; // 50KB limit for injected context
const ALLOWED_EXTENSIONS = ['.md', '.txt', '.json', '.yml', '.yaml'];

// Schema for the ui_inject tool
export const injectSchema = z.object({
  name: z.literal('ui_inject'),
  description: z.literal('Inject context or expert knowledge into the current session'),
  inputSchema: z.object({
    type: z.literal('object'),
    properties: z.object({
      action: z.object({
        type: z.literal('string'),
        enum: z.array(z.literal('inject').or(z.literal('help'))),
        description: z.literal('Action to perform'),
        default: z.literal('inject')
      }).optional(),
      type: z.object({
        type: z.literal('string'),
        enum: z.array(z.literal('context').or(z.literal('expert').or(z.literal('federation')))),
        description: z.literal('Type of injection: context for general knowledge, expert for specialized modules, federation for instance context')
      }),
      source: z.object({
        type: z.literal('object'),
        properties: z.object({
          instance: z.object({
            type: z.literal('string'),
            description: z.literal('Target instance ID (e.g., CCI, CCD, CCB)')
          }),
          mode: z.object({
            type: z.literal('string'),
            enum: z.array(z.literal('default').or(z.literal('custom'))),
            description: z.literal('Mode for federation injection'),
            default: z.literal('default')
          }).optional()
        }),
        description: z.literal('For context: file path or URL. For expert: module name. For federation: { instance, mode }')
      }),
      validate: z.object({
        type: z.literal('boolean'),
        description: z.literal('Whether to validate the injected content'),
        default: z.literal(true)
      }).optional()
    }),
    required: z.array(z.literal('type').or(z.literal('source')))
  })
});

// V3 Security schemas with refined validation
export const InjectSchemas = {
  inject: z.object({
    action: z.enum(['inject', 'help']).default('inject'),
    type: z.enum(['context', 'expert', 'federation']),
    source: z.union([
      z.string().max(500),
      z.object({
        instance: z.string(),
        mode: z.enum(['default', 'custom']).default('default')
      })
    ]),
    validate: z.boolean().default(true),
    instanceId: zInstanceId.optional()
  }).strict().refine(
    (data) => {
      // Federation type must have object source
      if (data.type === 'federation') {
        return typeof data.source === 'object' && data.source !== null;
      }
      // Context and expert types must have string source
      if (data.type === 'context' || data.type === 'expert') {
        return typeof data.source === 'string';
      }
      return true;
    },
    {
      message: "Invalid source type for the specified injection type. Federation requires object { instance, mode? }, others require string."
    }
  )
};

// Rate limit configuration
const RATE_LIMITS = {
  inject: { max: 10, window: 300 }, // 10 injections per 5 minutes
  expert: { max: 5, window: 300 }   // 5 expert loads per 5 minutes
};

// Expert modules configuration
const EXPERT_MODULES = {
  docker: {
    path: '/Users/samuelatagana/Library/Mobile Documents/iCloud~md~obsidian/Documents/LegacyMind/Experts/Docker',
    files: ['Docker_Expert_Guide.md', 'Docker_Best_Practices.md'],
    description: 'Docker containerization expertise'
  },
  mcp: {
    path: '/Users/samuelatagana/Library/Mobile Documents/iCloud~md~obsidian/Documents/LegacyMind/Experts/MCP',
    files: ['MCP_Development_Operations_Hub.md', 'MCP_Architecture.md'],
    description: 'Model Context Protocol development expertise'
  },
  postgresql: {
    path: '/Users/samuelatagana/Library/Mobile Documents/iCloud~md~obsidian/Documents/LegacyMind/Experts/PostgreSQL',
    files: ['PostgreSQL_Expert_Guide.md', 'PostgreSQL_Performance.md'],
    description: 'PostgreSQL database expertise'
  },
  qdrant: {
    path: '/Users/samuelatagana/Library/Mobile Documents/iCloud~md~obsidian/Documents/LegacyMind/Experts/Qdrant',
    files: ['Qdrant_Expert_Guide.md', 'Qdrant_Vector_Operations.md'],
    description: 'Qdrant vector database expertise'
  },
  redis: {
    path: '/Users/samuelatagana/Library/Mobile Documents/iCloud~md~obsidian/Documents/LegacyMind/Experts/Redis',
    files: ['Redis_Expert_Guide.md', 'Redis_Data_Structures.md'],
    description: 'Redis in-memory database expertise'
  }
};

export class InjectTool {
  constructor(logger, sessionManager, rememberTool = null) {
    this.logger = logger;
    this.sessionManager = sessionManager;
    this.rememberTool = rememberTool;
    this.redisManager = redisManager;
  }

  async execute(args) {
    try {
      // Handle both direct params and nested structure
      let params = args.type ? args : (args.params || args);
      
      // Check for help action before validation
      if (params.action === 'help') {
        return this.getHelp();
      }
      
      // Handle JSON string source for federation type
      if (params.type === 'federation' && typeof params.source === 'string') {
        try {
          // Try to parse the source if it's a JSON string
          const parsedSource = JSON.parse(params.source);
          params = { ...params, source: parsedSource };
          this.logger.debug('Parsed federation source from JSON string', { parsedSource });
        } catch (e) {
          // Not valid JSON, will fail validation
          this.logger.debug('Federation source is not valid JSON, proceeding with string');
        }
      }
      
      // V3 Security: Validate input
      const validated = InjectSchemas.inject.parse(params);
      const { action = 'inject', type, source, validate = true, instanceId } = validated;
      
      // Additional validation: federation requires object source
      if (type === 'federation' && typeof source !== 'object') {
        throw new Error('Federation type requires source to be an object with { instance: "instanceId", mode?: "default" | "custom" }');
      }
      
      // Generate correlation ID for tracking
      const correlationId = uuidv4();

      this.logger.info(`Executing ui_inject: type=${type}, source=${JSON.stringify(source)}, correlationId=${correlationId}`);
      
      // Get the active session
      const activeSession = await this.sessionManager.getActiveSession();
      if (!activeSession) {
        throw new Error('No active session found. Please check in first.');
      }
      
      const effectiveInstanceId = instanceId || activeSession.instanceId;
      
      // V3 Security: Rate limiting
      const isRateLimited = await rateLimiter.check(
        effectiveInstanceId,
        `inject_${type}`,
        type === 'expert' ? RATE_LIMITS.expert : RATE_LIMITS.inject
      );
      
      if (isRateLimited) {
        throw new Error(`Rate limit exceeded for ${type} injection. Please wait before trying again.`);
      }

      let content;
      let metadata = {
        type,
        source,
        timestamp: new Date().toISOString(),
        correlationId,
        instanceId: effectiveInstanceId
      };

      if (type === 'expert') {
        content = await this.loadExpertModule(source);
        metadata.expert = {
          module: source,
          description: EXPERT_MODULES[source]?.description
        };
      } else if (type === 'context') {
        content = await this.loadContextFile(source);
        metadata.context = {
          path: source,
          size: content.length
        };
      } else if (type === 'federation') {
        // Load context from another instance
        const federationResult = await this.loadFederationContext(source, effectiveInstanceId);
        content = federationResult.content;
        metadata.federation = federationResult.metadata;
      }

      // Validate content if requested
      if (validate) {
        await this.validateContent(content, type);
      }

      // V3 Security: Store as Redis Hash using atomic pipeline
      await this.redisManager.execute('default', async () => {
        const client = this.redisManager.connections.get('default');
        const pipeline = client.multi();
        
        if (type === 'expert') {
          // Store expert modules as Redis Hash
          const expertKey = `expert:${effectiveInstanceId}:${source}`;
          const expertData = {
            module: source,
            content: content,
            loadedAt: new Date().toISOString(),
            correlationId: correlationId,
            sessionId: activeSession.id,
            description: EXPERT_MODULES[source]?.description || ''
          };
          
          // Store each field separately in the hash
          for (const [field, value] of Object.entries(expertData)) {
            pipeline.hset(expertKey, field, value);
          }
          pipeline.expire(expertKey, 86400); // 24 hour TTL
          
          // Track in active experts set
          pipeline.sadd(`active_experts:${effectiveInstanceId}`, source);
          pipeline.expire(`active_experts:${effectiveInstanceId}`, 86400);
        } else {
          // Store context injection
          const contextKey = KEY_SCHEMA.CONTEXT(effectiveInstanceId);
          const contextData = {
            type: 'injected',
            source: source,
            content: content,
            sessionId: activeSession.id,
            correlationId: correlationId,
            injectedAt: new Date().toISOString()
          };
          
          // Store as hash
          for (const [field, value] of Object.entries(contextData)) {
            pipeline.hset(contextKey.key, field, value);
          }
          pipeline.expire(contextKey.key, contextKey.ttl);
        }
        
        // Execute pipeline atomically
        await pipeline.exec();
      });

      // Update session activity
      await this.sessionManager.updateActivity(effectiveInstanceId);

      this.logger.info(`Successfully injected ${type} content: ${source}, correlationId=${correlationId}`);

      return {
        success: true,
        type,
        source,
        contentSize: content.length,
        metadata,
        correlationId,
        message: `Successfully injected ${type} content from ${source}`
      };

    } catch (error) {
      this.logger.error(`Error in ui_inject:`, error);
      throw error;
    }
  }

  async loadExpertModule(moduleName) {
    // V3 Security: Validate module name
    const normalizedName = moduleName.toLowerCase().trim();
    if (!/^[a-z0-9_-]+$/.test(normalizedName)) {
      throw new Error('Invalid module name format');
    }
    
    const module = EXPERT_MODULES[normalizedName];
    if (!module) {
      throw new Error(`Unknown expert module: ${moduleName}. Available modules: ${Object.keys(EXPERT_MODULES).join(', ')}`);
    }

    const contents = [];
    for (const filename of module.files) {
      const filePath = path.join(module.path, filename);
      try {
        const content = await fs.readFile(filePath, 'utf-8');
        contents.push(`\n## ${filename}\n\n${content}`);
      } catch (error) {
        this.logger.warn(`Could not load expert file ${filePath}: ${error.message}`);
      }
    }

    if (contents.length === 0) {
      throw new Error(`No expert content found for module: ${moduleName}`);
    }

    return `# Expert Module: ${moduleName}\n${module.description}\n${contents.join('\n')}`;
  }

  async loadContextFile(source) {
    // Check if source is a file path
    if (source.startsWith('/') || source.startsWith('./')) {
      return await this.loadLocalFile(source);
    }
    
    // Check if source is a URL
    if (source.startsWith('http://') || source.startsWith('https://')) {
      return await this.loadFromURL(source);
    }

    throw new Error(`Invalid source: ${source}. Must be a file path or URL`);
  }

  async loadLocalFile(filePath) {
    // Validate file extension
    const ext = path.extname(filePath).toLowerCase();
    if (!ALLOWED_EXTENSIONS.includes(ext)) {
      throw new Error(`File type not allowed: ${ext}. Allowed types: ${ALLOWED_EXTENSIONS.join(', ')}`);
    }

    // Check file size
    const stats = await fs.stat(filePath);
    if (stats.size > MAX_CONTEXT_SIZE) {
      throw new Error(`File too large: ${stats.size} bytes. Maximum allowed: ${MAX_CONTEXT_SIZE} bytes`);
    }

    // Read file content
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  }

  async loadFromURL(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const contentLength = response.headers.get('content-length');
      if (contentLength && parseInt(contentLength) > MAX_CONTEXT_SIZE) {
        throw new Error(`Content too large: ${contentLength} bytes. Maximum allowed: ${MAX_CONTEXT_SIZE} bytes`);
      }

      const content = await response.text();
      if (content.length > MAX_CONTEXT_SIZE) {
        throw new Error(`Content too large: ${content.length} bytes. Maximum allowed: ${MAX_CONTEXT_SIZE} bytes`);
      }

      return content;
    } catch (error) {
      throw new Error(`Failed to fetch URL: ${error.message}`);
    }
  }

  async validateContent(content, type) {
    // V3 Security: Enhanced validation
    if (!content || typeof content !== 'string') {
      throw new Error('Invalid content: must be a non-empty string');
    }

    if (content.length === 0) {
      throw new Error('Content is empty');
    }

    // V3 Security: Strict size limit (50KB)
    if (content.length > MAX_CONTEXT_SIZE) {
      throw new Error(`Content too large: ${content.length} bytes. Maximum allowed: ${MAX_CONTEXT_SIZE} bytes`);
    }
    
    // Additional validation for content structure
    try {
      // Use zContent validator for sanitization
      zContent.parse(content.substring(0, 10000)); // Validate first 10KB
    } catch (error) {
      throw new Error('Content validation failed: ' + error.message);
    }

    // Type-specific validation
    if (type === 'expert') {
      // Ensure expert content has expected structure
      if (!content.includes('# Expert Module:')) {
        throw new Error('Invalid expert module content structure');
      }
    }

    // Check for potentially harmful content
    const suspiciousPatterns = [
      /<script[\s\S]*?<\/script>/gi,
      /javascript:/gi,
      /on\w+\s*=/gi
    ];

    for (const pattern of suspiciousPatterns) {
      if (pattern.test(content)) {
        throw new Error('Content contains potentially unsafe patterns');
      }
    }

    return true;
  }

  async loadFederationContext(source, requestingInstanceId) {
    const { instance: targetInstance, mode = 'default' } = source;
    
    // Validate instance name
    if (!targetInstance || typeof targetInstance !== 'string') {
      throw new Error('Invalid federation source: instance is required');
    }
    
    this.logger.info(`Loading federation context from ${targetInstance} for ${requestingInstanceId}`);
    
    try {
      // Use Promise.allSettled for parallel loading with resilience
      const contextPromises = [];
      
      // 1. Load identity from ui_remember
      contextPromises.push(
        this.loadFromRememberTool(targetInstance, 'identity', 'Federation Identity')
      );
      
      // 2. Load context from ui_remember
      contextPromises.push(
        this.loadFromRememberTool(targetInstance, 'context', 'Federation Context')
      );
      
      // 3. Load curiosity from ui_remember
      contextPromises.push(
        this.loadFromRememberTool(targetInstance, 'curiosity', 'Federation Curiosity')
      );
      
      // 4. Load recent thoughts from ui_think
      contextPromises.push(
        this.loadRecentThoughts(targetInstance, 'Recent Thoughts')
      );
      
      // Execute all loads in parallel
      const results = await Promise.allSettled(contextPromises);
      
      // Process results
      const sections = [];
      const metadata = {
        targetInstance,
        mode,
        loadedAt: new Date().toISOString(),
        components: {}
      };
      
      results.forEach((result, index) => {
        const componentNames = ['identity', 'context', 'curiosity', 'thoughts'];
        const componentName = componentNames[index];
        
        if (result.status === 'fulfilled' && result.value) {
          sections.push(result.value);
          metadata.components[componentName] = {
            loaded: true,
            size: result.value.length
          };
        } else {
          metadata.components[componentName] = {
            loaded: false,
            error: result.reason?.message || 'Failed to load'
          };
          this.logger.warn(`Failed to load ${componentName} for ${targetInstance}:`, result.reason);
        }
      });
      
      if (sections.length === 0) {
        throw new Error(`No federation context available for instance: ${targetInstance}`);
      }
      
      const content = `# Federation Context: ${targetInstance}\n\n${sections.join('\n\n')}`;
      
      return {
        content,
        metadata
      };
      
    } catch (error) {
      this.logger.error(`Failed to load federation context from ${targetInstance}:`, error);
      throw new Error(`Failed to load federation context: ${error.message}`);
    }
  }
  
  async loadFromRememberTool(instanceId, memoryType, sectionTitle) {
    try {
      // Call the remember tool API via the RememberTool instance
      const rememberTool = this.sessionManager?.rememberTool || this.rememberTool;
      if (!rememberTool) {
        throw new Error('RememberTool not available');
      }
      
      // Temporarily set the instance context
      const originalInstanceId = rememberTool.currentInstanceId;
      rememberTool.setCurrentInstanceId(instanceId);
      
      try {
        const result = await rememberTool.execute({ 
          action: 'list',
          memory_type: memoryType, 
          options: { limit: 5 } 
        });
        
        if (result.memories && result.memories.length > 0) {
          const content = result.memories
            .map(m => `- ${m.content}`)
            .join('\n');
          return `## ${sectionTitle}\n\n${content}`;
        }
        
        return null;
      } finally {
        // Restore original instance context
        if (originalInstanceId) {
          rememberTool.setCurrentInstanceId(originalInstanceId);
        }
      }
      
    } catch (error) {
      this.logger.warn(`Failed to load ${memoryType} for ${instanceId}:`, error.message);
      return null;
    }
  }
  
  async loadRecentThoughts(instanceId, sectionTitle) {
    try {
      // Access thoughts via Redis directly for now
      // In future, this should call ui_think API
      const thoughtsKey = KEY_SCHEMA.THOUGHTS_STREAM(instanceId);
      const thoughts = await this.redisManager.execute('search', async () => {
        const client = this.redisManager.connections.get('search');
        return await client.xrevrange(thoughtsKey.key, '+', '-', 'COUNT', 10);
      });
      
      if (thoughts && thoughts.length > 0) {
        const content = thoughts
          .map(([id, fields]) => `- ${fields.content}`)
          .join('\n');
        return `## ${sectionTitle}\n\n${content}`;
      }
      
      return null;
      
    } catch (error) {
      this.logger.warn(`Failed to load thoughts for ${instanceId}:`, error.message);
      return null;
    }
  }
  
  getHelp() {
    return {
      tool: 'ui_inject',
      version: '3.1',
      description: 'Enhanced context injection with federation support and parallel loading',
      actions: {
        inject: {
          description: 'Inject context, expert knowledge, or federation context',
          types: {
            context: {
              description: 'Load custom files or URLs',
              source: 'File path or URL string',
              example: '{ "type": "context", "source": "/path/to/file.md" }'
            },
            expert: {
              description: 'Load expert knowledge modules',
              source: 'Module name: docker, mcp, postgresql, qdrant, redis',
              example: '{ "type": "expert", "source": "mcp" }'
            },
            federation: {
              description: 'Load context from another instance',
              source: '{ instance: "CCI", mode: "default" }',
              example: '{ "type": "federation", "source": { "instance": "CCI" } }',
              features: [
                'Parallel loading of identity, context, curiosity, and thoughts',
                'Graceful handling of missing components',
                'Cross-instance context support for troubleshooting'
              ]
            }
          }
        },
        help: {
          description: 'Get this help information',
          example: '{ "action": "help" }'
        }
      },
      security: {
        validation: 'Content validation enabled by default',
        sizeLimit: '50KB maximum content size',
        rateLimit: '10 injections per 5 minutes (5 for expert modules)',
        allowedTypes: ALLOWED_EXTENSIONS
      },
      philosophy: 'Service-oriented context injection with parallel loading and cross-instance support'
    };
  }
  
  getSchema() {
    return injectSchema.shape;
  }
}

// V3 Security: Auto-inject functionality
export async function autoInjectContext(instanceId, sessionManager) {
  try {
    const client = redisManager.connections.get('default');
    
    // Load active experts atomically
    const activeExperts = await client.smembers(`active_experts:${instanceId}`);
    const contexts = [];
    
    for (const expertName of activeExperts) {
      const expertKey = `expert:${instanceId}:${expertName}`;
      const expertData = await client.hgetall(expertKey);
      
      if (expertData && expertData.content) {
        contexts.push({
          type: 'expert',
          name: expertName,
          content: expertData.content,
          loadedAt: expertData.loadedAt
        });
      }
    }
    
    // Load general context
    const contextKey = KEY_SCHEMA.CONTEXT(instanceId);
    const contextData = await client.hgetall(contextKey.key);
    
    if (contextData && contextData.content) {
      contexts.push({
        type: 'context',
        source: contextData.source,
        content: contextData.content,
        injectedAt: contextData.injectedAt
      });
    }
    
    return contexts;
  } catch (error) {
    logger.error('Error in autoInjectContext:', error);
    return [];
  }
}

export const createInjectTool = (logger, sessionManager, rememberTool = null) => {
  return new InjectTool(logger, sessionManager, rememberTool);
};